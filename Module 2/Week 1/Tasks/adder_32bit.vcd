$date
	Tue Dec 16 14:37:02 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb_adder_32bit $end
$var wire 32 ! sum [31:0] $end
$var wire 1 " cout $end
$var reg 32 # a [31:0] $end
$var reg 32 $ b [31:0] $end
$var reg 1 % cin $end
$scope module uut $end
$var wire 32 & a [31:0] $end
$var wire 32 ' b [31:0] $end
$var wire 1 % cin $end
$var wire 32 ( sum [31:0] $end
$var wire 1 " cout $end
$var wire 32 ) adder_sum [31:0] $end
$var wire 5 * adder_cout [4:0] $end
$scope begin CLA_BLOCKS[0] $end
$var parameter 2 + i $end
$scope module cla_inst $end
$var wire 8 , G [7:0] $end
$var wire 8 - P [7:0] $end
$var wire 8 . a [7:0] $end
$var wire 8 / b [7:0] $end
$var wire 1 0 cin $end
$var wire 8 1 sum [7:0] $end
$var wire 1 2 cout $end
$var wire 9 3 C [8:0] $end
$var parameter 32 4 DATA_WIDTH $end
$scope begin CLA_CARRY[0] $end
$var parameter 2 5 i $end
$upscope $end
$scope begin CLA_CARRY[1] $end
$var parameter 2 6 i $end
$upscope $end
$scope begin CLA_CARRY[2] $end
$var parameter 3 7 i $end
$upscope $end
$scope begin CLA_CARRY[3] $end
$var parameter 3 8 i $end
$upscope $end
$scope begin CLA_CARRY[4] $end
$var parameter 4 9 i $end
$upscope $end
$scope begin CLA_CARRY[5] $end
$var parameter 4 : i $end
$upscope $end
$scope begin CLA_CARRY[6] $end
$var parameter 4 ; i $end
$upscope $end
$scope begin CLA_CARRY[7] $end
$var parameter 4 < i $end
$upscope $end
$upscope $end
$upscope $end
$scope begin CLA_BLOCKS[1] $end
$var parameter 2 = i $end
$scope module cla_inst $end
$var wire 8 > G [7:0] $end
$var wire 8 ? P [7:0] $end
$var wire 8 @ a [7:0] $end
$var wire 8 A b [7:0] $end
$var wire 1 B cin $end
$var wire 8 C sum [7:0] $end
$var wire 1 D cout $end
$var wire 9 E C [8:0] $end
$var parameter 32 F DATA_WIDTH $end
$scope begin CLA_CARRY[0] $end
$var parameter 2 G i $end
$upscope $end
$scope begin CLA_CARRY[1] $end
$var parameter 2 H i $end
$upscope $end
$scope begin CLA_CARRY[2] $end
$var parameter 3 I i $end
$upscope $end
$scope begin CLA_CARRY[3] $end
$var parameter 3 J i $end
$upscope $end
$scope begin CLA_CARRY[4] $end
$var parameter 4 K i $end
$upscope $end
$scope begin CLA_CARRY[5] $end
$var parameter 4 L i $end
$upscope $end
$scope begin CLA_CARRY[6] $end
$var parameter 4 M i $end
$upscope $end
$scope begin CLA_CARRY[7] $end
$var parameter 4 N i $end
$upscope $end
$upscope $end
$upscope $end
$scope begin CLA_BLOCKS[2] $end
$var parameter 3 O i $end
$scope module cla_inst $end
$var wire 8 P G [7:0] $end
$var wire 8 Q P [7:0] $end
$var wire 8 R a [7:0] $end
$var wire 8 S b [7:0] $end
$var wire 1 T cin $end
$var wire 8 U sum [7:0] $end
$var wire 1 V cout $end
$var wire 9 W C [8:0] $end
$var parameter 32 X DATA_WIDTH $end
$scope begin CLA_CARRY[0] $end
$var parameter 2 Y i $end
$upscope $end
$scope begin CLA_CARRY[1] $end
$var parameter 2 Z i $end
$upscope $end
$scope begin CLA_CARRY[2] $end
$var parameter 3 [ i $end
$upscope $end
$scope begin CLA_CARRY[3] $end
$var parameter 3 \ i $end
$upscope $end
$scope begin CLA_CARRY[4] $end
$var parameter 4 ] i $end
$upscope $end
$scope begin CLA_CARRY[5] $end
$var parameter 4 ^ i $end
$upscope $end
$scope begin CLA_CARRY[6] $end
$var parameter 4 _ i $end
$upscope $end
$scope begin CLA_CARRY[7] $end
$var parameter 4 ` i $end
$upscope $end
$upscope $end
$upscope $end
$scope begin CLA_BLOCKS[3] $end
$var parameter 3 a i $end
$scope module cla_inst $end
$var wire 8 b G [7:0] $end
$var wire 8 c P [7:0] $end
$var wire 8 d a [7:0] $end
$var wire 8 e b [7:0] $end
$var wire 1 f cin $end
$var wire 8 g sum [7:0] $end
$var wire 1 h cout $end
$var wire 9 i C [8:0] $end
$var parameter 32 j DATA_WIDTH $end
$scope begin CLA_CARRY[0] $end
$var parameter 2 k i $end
$upscope $end
$scope begin CLA_CARRY[1] $end
$var parameter 2 l i $end
$upscope $end
$scope begin CLA_CARRY[2] $end
$var parameter 3 m i $end
$upscope $end
$scope begin CLA_CARRY[3] $end
$var parameter 3 n i $end
$upscope $end
$scope begin CLA_CARRY[4] $end
$var parameter 4 o i $end
$upscope $end
$scope begin CLA_CARRY[5] $end
$var parameter 4 p i $end
$upscope $end
$scope begin CLA_CARRY[6] $end
$var parameter 4 q i $end
$upscope $end
$scope begin CLA_CARRY[7] $end
$var parameter 4 r i $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b111 r
b110 q
b101 p
b100 o
b11 n
b10 m
b1 l
b0 k
b1000 j
b11 a
b111 `
b110 _
b101 ^
b100 ]
b11 \
b10 [
b1 Z
b0 Y
b1000 X
b10 O
b111 N
b110 M
b101 L
b100 K
b11 J
b10 I
b1 H
b0 G
b1000 F
b1 =
b111 <
b110 ;
b101 :
b100 9
b11 8
b10 7
b1 6
b0 5
b1000 4
b0 +
$end
#0
$dumpvars
b0 i
0h
b0 g
0f
b0 e
b0 d
b0 c
b0 b
b0 W
0V
b0 U
0T
b0 S
b0 R
b0 Q
b0 P
b0 E
0D
b0 C
0B
b0 A
b0 @
b0 ?
b0 >
b10 3
02
b10 1
00
b1 /
b1 .
b0 -
b1 ,
b0 *
b10 )
b10 (
b1 '
b1 &
0%
b1 $
b1 #
0"
b10 !
$end
#10000
1"
1h
b111111111 i
1f
1V
b111111111 W
1T
1D
b111111111 E
1B
b11110 *
12
b111111110 3
b0 1
b0 C
b0 U
b0 !
b0 (
b0 )
b0 g
b11111110 -
b11111111 ?
b11111111 Q
b11111111 c
b11111111 .
b11111111 @
b11111111 R
b11111111 d
b11111111111111111111111111111111 #
b11111111111111111111111111111111 &
#20000
0"
0h
0B
0f
02
0V
0T
0D
b11111000 E
b10 W
b0 i
b10100110 1
b10010011 C
b10011110 U
b11010010100111101001001110100110 !
b11010010100111101001001110100110 (
b11010010100111101001001110100110 )
b11010010 g
b0 ,
b10100101 -
b10100 >
b1101011 ?
b1 P
b10011100 Q
b11010010 c
b11 3
10
b10000001 /
b1011110 A
b10001001 S
b11000000 e
b100100 .
b110101 @
b10101 R
b10010 d
b1 *
1%
b11000000100010010101111010000001 $
b11000000100010010101111010000001 '
b10010000101010011010100100100 #
b10010000101010011010100100100 &
#30000
b1111 i
1f
b11111 3
b1001 *
1V
b11111100 E
b111100000 W
b1110001 1
b11010001 C
b10101001 U
b10111000101010011101000101110001 !
b10111000101010011101000101110001 (
b10111000101010011101000101110001 )
b10111000 g
b1 ,
b1101110 -
b1010010 >
b101101 ?
b10110000 P
b1001001 Q
b10110111 c
b1101 /
b1111011 A
b10111001 S
b110 e
b1100011 .
b1010110 @
b11110000 R
b10110001 d
b110101110010111101100001101 $
b110101110010111101100001101 '
b10110001111100000101011001100011 #
b10110001111100000101011001100011 &
#40000
0f
0V
0T
0D
1"
b1111 3
b10001 *
1h
b0 E
b1100 W
b100000000 i
b1111000 1
b11010110 C
b11111001 U
b111011111110011101011001111000 !
b111011111110011101011001111000 (
b111011111110011101011001111000 )
b111011 g
b0 ,
b1110111 -
b0 >
b11010110 ?
b10 P
b11110101 Q
b10000000 b
b111011 c
b10010 /
b1010010 A
b110111 S
b10001001 e
b1100101 .
b10000100 @
b11000010 R
b10110010 d
b10001001001101110101001000010010 $
b10001001001101110101001000010010 '
b10110010110000101000010001100101 #
b10110010110000101000010001100101 &
#50000
1T
0"
b11111111 3
1D
b101 *
0h
b110000010 E
b1111 W
b1111100 i
b10000100 1
b10111110 C
b11111011 U
b1000001111110111011111010000100 !
b1000001111110111011111010000100 (
b1000001111110111011111010000100 )
b1000001 g
b100 ,
b1111011 -
b11000001 >
b111100 ?
b11 P
b11110100 Q
b10 b
b111101 c
b1110110 /
b11110001 A
b100011 S
b111011 e
b1101 .
b11001101 @
b11010111 R
b110 d
b111011001000111111000101110110 $
b111011001000111111000101110110 '
b110110101111100110100001101 #
b110110101111100110100001101 &
#60000
1f
1V
1B
b1111 *
12
b100011011 3
b111101111 E
b111111011 W
b10001101 i
b1111010 1
b1001111 C
b10 U
b10111101000000100100111101111010 !
b10111101000000100100111101111010 (
b10111101000000100100111101111010 )
b10111101 g
b10001100 ,
b1100001 -
b1010111 >
b10100000 ?
b100 P
b11111001 Q
b1000110 b
b110000 c
b10001100 /
b11110111 A
b101101 S
b1000110 e
b11101101 .
b1010111 @
b11010100 R
b1110110 d
b1000110001011011111011110001100 $
b1000110001011011111011110001100 '
b1110110110101000101011111101101 #
b1110110110101000101011111101101 &
#70000
